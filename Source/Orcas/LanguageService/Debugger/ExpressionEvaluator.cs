//© Đonny 2008, part of Phalanger project
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.Debugger.Interop;
using Microsoft.Win32;
using Microsoft.VisualStudio;
using System.Diagnostics;

namespace PHP.VisualStudio.PhalangerLanguageService.Debugger {
    /// <summary>Implements expression evaluator for PHP debugger</summary>
    [ComVisible(true)]
    [Guid(PHPExpressionEvaluator.EEGuid)]
    public class PHPExpressionEvaluator:IDebugExpressionEvaluator2 {
        /// <summary>CTor</summary>
        public PHPExpressionEvaluator() {}
        #region IDebugExpressionEvaluator2 Members
        /// <summary>This method converts a method location and offset into a memory address. </summary>
        /// <param name="upstrFullyQualifiedMethodPlusOffset">[in] The method location and offset, expressed as a string. </param>
        /// <param name="pSymbolProvider">[in] The symbol provider expressed as an <see cref="IDebugSymbolProvider"/> object. </param>
        /// <param name="pAddress">[in] An address within the method, expressed as an <see cref="IDebugAddress"/> object. </param>
        /// <param name="pBinder">[in] The binder expressed as an <see cref="IDebugBinder"/> object. </param>
        /// <param name="ppProperty">[out] Returns an <see cref="DebugProperty2"/> interface that represents the memory address. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code.</returns>
        /// <remarks>The returned address can be used to set a breakpoint, for example. 
        /// <para>Despite the name upstrFullyQualifiedMethodPlusOffset, this parameter can be passed a partially qualified method name. In that case, the selected method is the one that encloses pAddress. How this parameter is interpreted is up to the implementation of the expression evaluator and the language it supports. </para></remarks>
        public int GetMethodLocationProperty(string upstrFullyQualifiedMethodPlusOffset, IDebugSymbolProvider pSymbolProvider, IDebugAddress pAddress, IDebugBinder pBinder, out IDebugProperty2 ppProperty) {
            ppProperty = null;
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>This method gets a property object that contains the locals, arguments, and other properties of a method.</summary>
        /// <param name="pSymbolProvider">[in] The symbol provider to be used, expressed as an <see cref="IDebugSymbolProvider"/> object. </param>
        /// <param name="pAddress">[in] The address in code, expressed as an <see cref="IDebugAddress"/> object, that should be resolved to the nearest containing function. </param>
        /// <param name="pBinder">[in] The binder to be used, expressed as an <see cref="IDebugBinder"/> object. </param>
        /// <param name="ppProperty">[out] Returns an IDebugProperty2 object that represents the method. </param>
        /// <param name="fIncludeHiddenLocals">[in] Nonzero (TRUE)means to include hidden locals; zero (FALSE) means to leave out hidden locals </param>
        /// <remarks>Hidden locals are typically variables that are generated by the compiler. </remarks>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        public int GetMethodProperty(IDebugSymbolProvider pSymbolProvider, IDebugAddress pAddress, IDebugBinder pBinder, int fIncludeHiddenLocals, out IDebugProperty2 ppProperty) {
            //TODO: This code is copied from example, phalanger needs refinement
            ppProperty = null;

            DebuggerContext context = new DebuggerContext(pSymbolProvider, pAddress, pBinder);
            IDebugContainerField container;
            NativeMethods.ThrowOnFailure(
                pSymbolProvider.GetContainerField(pAddress, out container));
            if(container == null) {
                return VSConstants.E_FAIL;
            }

            // If this is a method then return the field for the method
            EEDebugContainerField eeContainer = new EEDebugContainerField(container);
            if(eeContainer.IsMethod) {
                PropertyFactory factory = new PropertyFactory(context);
                PropertyBase ppProp;
                int hr;
                if(NativeMethods.Failed(
                    hr = factory.CreateMethodProperty(new PropertyContext(context), eeContainer, out ppProp))) return hr;
                #region "This returns PHP locals. Comment it out and youl'll get CLR locals
                    //try {
                    //    var locals = PHPDebugExpression.GetLocalObject("<locals>",context,0);
                    //    ppProp = factory.CreatePHPMethodProperty(new PropertyContext(context), eeContainer, locals.Object);
                    //} catch(Exception ex) {
                    //    return Marshal.GetHRForException(ex);
                    //}
                #endregion
                ppProperty = ppProp; 
                return hr;
            }

            return VSConstants.E_FAIL;
        }
        /// <summary>Retrieves a service object given its unique identifier. </summary>
        /// <param name="ppService">[out] Returns an object that represents the service. </param>
        /// <param name="uid">[in] Unique identifier of the service to retrieve. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        /// <remarks>This can be consumed by a third-party expression evaluator to obtain services from another expression evaluator. For example, this method could be used to obtain the interface for the visualizer service from the default expression evaluator. Third-party expression evaluators are unlikely to need to implement this interface.</remarks>
        public int GetService(Guid uid, out object ppService) {
            ppService = null;
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>This method converts an expression string to a parsed expression. </summary>
        /// <param name="upstrExpression">[in] The expression string to be parsed. </param>
        /// <param name="dwFlags">[in] A collection of PARSEFLAGS constants that determine how the expression is to be parsed. </param>
        /// <param name="nRadix">in] Radix to be used to interpret any numerical information. </param>
        /// <param name="pbstrError">[out] Returns the error as human-readable text. </param>
        /// <param name="pichError">[out] Returns the character position of the start of the error in the expression string. </param>
        /// <param name="ppParsedExpression">[out] Returns the parsed expression in an IDebugParsedExpression object. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code</returns>
        /// <remarks>This method produces a parsed expression, not an actual value. A parsed expression is ready to be evaluated, that is, converted to a value.</remarks>
        public int Parse(string upstrExpression, uint dwFlags, uint nRadix, out string pbstrError, out uint pichError, out IDebugParsedExpression ppParsedExpression) {
            pbstrError = null;
            pichError = 0;
            if(upstrExpression == null || upstrExpression == "") {
                ppParsedExpression = null;
                return VSConstants.E_INVALIDARG;
            }
            ppParsedExpression = new PHPDebugExpression(upstrExpression);
            return VSConstants.S_OK;
        }
        /// <summary>Preloads the modules designated by the specified symbol provider. </summary>
        /// <param name="pSym">[in] Symbol provider for which the modules will be preloaded. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        /// <remarks>This optional method is used when you do a hosting-process attach. It gives the EE a chance to ‘warm up’ as part of the attach. </remarks>
        public int PreloadModules(IDebugSymbolProvider pSym) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>Enables the expression evaluator (EE) to specify the callback interface that the debugger engine (DE) will use to read metric settings.</summary>
        /// <param name="pCallback">[in] Interface to use for the settings callback. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        /// <remarks>This method provides an interface to the session debug manager that an expression evaluator can use to read metric settings. It is useful in remote debugging to read metrics on the Visual Studio computer.</remarks>
        public int SetCallback(IDebugSettingsCallback2 pCallback) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>Sets the path to the common language runtime (CLR) loaded in the debugger. </summary>
        /// <param name="pcstrCorPath">[in] Path to the CLR loaded in the debugger. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        public int SetCorPath(string pcstrCorPath) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>Enables a debug engine to pass a callback to the expression evaluator during initialization. </summary>
        /// <param name="pCallback">[in] Interface for the callback. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        public int SetIDebugIDECallback(IDebugIDECallback pCallback) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>This method sets the language to use to create printable results. </summary>
        /// <param name="wLangID">[in] The language identifier. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        /// <remarks>This method may be called many times while the expression evaluator (EE) is loaded, so the EE must be able to switch languages on the fly. The EE uses this locale to return error messages and strings in the appropriate language.</remarks>
        public int SetLocale(ushort wLangID) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>This method sets the registry root. Used for side-by-side debugging. </summary>
        /// <param name="ustrRegistryRoot">[in] The new registry root. </param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns> 
        /// <remarks>The specified registry root is typically set when the expression evaluator is first instantiated and points to the registry key for a specific version of Visual Studio (HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\X.Y, where X.Y is a version number). </remarks>
        public int SetRegistryRoot(string ustrRegistryRoot) {
            return VSConstants.E_NOTIMPL;
        }
        /// <summary>Stops and cleans up the expression evaluator. </summary>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code. </returns>
        /// <remarks>Tells the expression evaluator when it is being cleaned up. </remarks>
        public int Terminate() {
            return VSConstants.E_NOTIMPL;
        }

        #endregion

        #region COM registration
        /// <summary>Guid of this class</summary>
        internal const string EEGuid = "AC3840C2-E6B1-4778-B135-FE383E0DDA2F";
        //private static bool Registered, Unregistered;//To avoid duplicit calls
        ///// <summary>Registers Visual Studio Expression Eveluator for Phalanger</summary>
        ///// <param name="t">Ignored</param>
        //[ComRegisterFunction]
        //internal static void RegisterClass(Type t) {
        //    if(Registered) return;
        //    Registered = true;
        //    Unregistered = false;

        //}
        ///// <summary>Un-registers Visual Studio Expression Eveluator for Phalanger</summary>
        //[System.Runtime.InteropServices.ComUnregisterFunction]
        //internal static void UnRegisterClass(Type t) {
        //    if(Unregistered) return;
        //    Unregistered = true;
        //    Registered = false;
        //    RegisterExpressionEvaluatorAttribute rea = new RegisterExpressionEvaluatorAttribute(t)
        //}
        #endregion
    }

    /// <summary>Implements the <see cref="IDebugParsedExpression"/> interface for Phalanger bedugger expression</summary>
    [ComVisible(true)]
    internal class PHPDebugExpression:IDebugParsedExpression {
        /// <summary>Contains the expression to be evaluated (as phalanger do not need parsing, because of existence of eval)</summary>
        private string expression;
        /// <summary>CTor</summary>
        /// <param name="expr">String representation of expression in PHP language (as if for eval)</param>
        public PHPDebugExpression(string expr) {
            expression = expr;
        }

        /// <summary>This method evaluates the parsed expression and optionally casts the result to another data type.</summary>
        /// <param name="dwEvalFlags">[in] A combination of EVALFLAGS constants that control how the expression is to be evaluated. </param>
        /// <param name="pSymbolProvider">[in] The symbol provider, expressed as an IDebugSymbolProvider interface.</param>
        /// <param name="pAddress">[in] The current execution location within a method, expressed as an IDebugAddress interface.</param>
        /// <param name="pBinder">[in] The binder, expressed as an IDebugBinder interface.</param> 
        /// <param name="bstrResultType">[in] The type the result should be cast to. This argument can be a null value.</param>
        /// <param name="ppResult">[out] Returns the IDebugProperty2 interface that represents the results of evaluation.</param>
        /// <param name="dwTimeout">[in] Specifies the maximum time, in milliseconds, to wait before returning from this method. Use INFINITE to wait indefinitely.</param>
        /// <returns>If successful, returns S_OK; otherwise, returns an error code.</returns>
        /// <remarks>The expression evaluation context is given by pAddress, which makes it possible to determine the containing method and then use language scoping rules to determine the value of the symbols in the expression.</remarks>
        public int EvaluateSync(uint dwEvalFlags, uint dwTimeout, IDebugSymbolProvider pSymbolProvider, IDebugAddress pAddress,
            IDebugBinder pBinder, string bstrResultType, out IDebugProperty2 ppResult) {
            int hr;
            ppResult = null;
            DebuggerContext context = new DebuggerContext(pSymbolProvider, pAddress, pBinder);
            IDebugContainerField container;
            if(NativeMethods.Failed(
                hr = pSymbolProvider.GetContainerField(pAddress, out container))) return hr;
            if(container == null) {
                return VSConstants.E_FAIL;
            }
            EEDebugContainerField eeContainer = new EEDebugContainerField(container);
            IDebugObject result; 
            try {
                result = Eval(context, dwTimeout, "return (" + expression + ");");
            } catch(Exception ex) { return Marshal.GetHRForException(ex); }
            if((ppResult = result as IDebugProperty2) != null) return HResult.S_OK;//If I'm lucky
            PropertyContext pc = new PropertyContext(context);
            EEDebugObject resultEE = new EEDebugObject(result);
            EEDebugField typefield;
            if(NativeMethods.Failed(
                hr = resultEE.GetType(context, out typefield))) return hr;
            /*if(new ObjectWrapper(context, result).GetProperty().TypeName == "PHP.Core.Reflection.ClrObject")
                ppResult = new ClrObjectProperty(pc, resultEE, typefield, expression);
            else*/
                ppResult = new EvalObjectProperty(pc, resultEE, typefield, expression);
            return VSConstants.S_OK;
        }
       
        /// <summary>Evaluates PHP commands using eval</summary>
        /// <param name="context">Debugger context</param>
        /// <param name="dwTimeout">Timeout in ms</param>
        /// <param name="Commands">Commands to evaluate (each must end with ;). Use return to obtain a value.</param>
        /// <returns>Result of evaluation</returns>
        internal static IDebugObject Eval(DebuggerContext context,uint dwTimeout,string Commands){
            //IDebugObject CurrentScriptContext=GetCurrentScriptContext(context,dwTimeout);
            IDebugFunctionObject eval = GetFunction(context,"PHP.Core.DynamicCode","Eval");
            IDebugObject result;
            //return GetStaticFieldObjectOfCurrentClass("<typeDesc>", context, dwTimeout);
            var arguments = new IDebugObject[]{
                    /*string code (A code to be evaluated.)*/
                    CreateStringObject(eval,Commands),//0
                    /*x*/CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_BOOLEAN,true),//1
                    /*x*/GetCurrentScriptContext(context,dwTimeout),//2
                    /*Dictionary<string, object> definedVariables (Currently defined variables.)*/
                    GetLocalObject("<locals>",context,dwTimeout).Object,//3
                    //CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_CLASS,null),
                    /*DObject self (The current PhpObject in which method the eval is called. Can be a null reference.)*/
                    //CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_CLASS,null),
                    GetInstanceFieldObjectOfCurrentClass("<proxy>",context,dwTimeout),//4
                    /*DTypeDesc referringType (A type desc of the type whose method is calling the eval.)*/
                    GetStaticFieldObjectOfCurrentClass("<typeDesc>",context,dwTimeout),//5
                    //CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_CLASS,null),
                    /*string callerRelativeSourcePath (Relative rath to the source file of a calling script with respect to the source root)*/
                    CreateStringObject(eval,""),//6
                    /*int line (The line where eval is called.)*/
                    CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_I4,0), //7
                    /*int column (The column where eval is called)*/
                    CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_I4,0),//8
                    /*int containerId (Id of the containing transient module)*/
                    CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_I4,-1),//9
                    /*NamingContext namingContext*/
                    CreatePrimitiveObject(eval, enum_OBJECT_TYPE.OBJECT_TYPE_CLASS,null)//10
                };
            foreach(IDebugObject item in arguments) if(item == null) Marshal.ThrowExceptionForHR(HResult.E_UNEXPECTED); 
            int hr;
            hr = eval.Evaluate(arguments, (IntPtr)arguments.Length, dwTimeout, out result);
            NativeMethods.ThrowOnFailure(hr);
            return result;
        }
        /// <summary>Gets value of static field of current class as <see cref="IDebugObject"/></summary>
        /// <param name="name">Name of field</param>
        /// <param name="context">Debugger context</param>
        /// <param name="dwTimeout">Timeout in ms</param>
        /// <returns>Value of static field of current class</returns>
        internal static IDebugObject GetStaticFieldObjectOfCurrentClass(string name, DebuggerContext context, uint dwTimeout) {
            int hr;
            IDebugContainerField container;
            NativeMethods.ThrowOnFailure(context.SymbolProvider.GetContainerField(context.Address, out container));
            if(container == null)
                Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            EEDebugContainerField eeContainer = new EEDebugContainerField(container);
            if(eeContainer.IsMethod) {
                PropertyFactory factory = new PropertyFactory(context);
                PropertyBase ppProp;
                NativeMethods.ThrowOnFailure(
                    factory.CreateMethodProperty(new PropertyContext(context), eeContainer, out ppProp));
                string[] dotparts = ppProp.FullName.Split('.');
                string classname = string.Join(".", dotparts, 0, dotparts.Length - 1);
                IDebugClassField Class;
                NativeMethods.ThrowOnFailure(
                    context.SymbolProvider.GetClassTypeByName(classname, NAME_MATCH.nmCaseSensitive, out Class));
                IEnumDebugFields Children;
                NativeMethods.ThrowOnFailure(
                    hr=Class.EnumFields(
                        (uint)(enum_FIELD_KIND.FIELD_KIND_ALL),
                        (uint)enum_FIELD_MODIFIERS.FIELD_MOD_ALL,
                        name, NAME_MATCH.nmCaseSensitive, out Children));
                if(hr == HResult.S_FALSE) return null;
                uint Count;
                NativeMethods.ThrowOnFailure(
                    Children.GetCount(out Count));
                if(Count == 0) return null;
                IDebugField[] info = new IDebugField[Count];
                NativeMethods.ThrowOnFailure(
                    Children.Next(Count, info, ref Count));
                if(Count == 0) return null;
                IDebugObject ret;
                NativeMethods.ThrowOnFailure(
                    context.Binder.Bind(null, info[0], out ret));
                return ret;
            }
            Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            return null;//never happens
        }
        /// <summary>Gets value of instance field of current class as <see cref="IDebugObject"/></summary>
        /// <param name="name">Name of field</param>
        /// <param name="context">Debugger context</param>
        /// <param name="dwTimeout">Timeout in ms</param>
        /// <returns>Value of instance field of current class</returns>
        internal static IDebugObject GetInstanceFieldObjectOfCurrentClass(string name, DebuggerContext context, uint dwTimeout) {
            int hr;
            IDebugContainerField container;
            NativeMethods.ThrowOnFailure(context.SymbolProvider.GetContainerField(context.Address, out container));
            if(container == null)
                Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            EEDebugContainerField eeContainer = new EEDebugContainerField(container);
            if(eeContainer.IsMethod) {
                PropertyFactory factory = new PropertyFactory(context);
                PropertyBase ppProp;
                NativeMethods.ThrowOnFailure(
                    factory.CreateMethodProperty(new PropertyContext(context), eeContainer, out ppProp));
                string[] dotparts = ppProp.FullName.Split('.');
                string classname = string.Join(".", dotparts, 0, dotparts.Length - 1);
                IDebugClassField Class;
                NativeMethods.ThrowOnFailure(
                    context.SymbolProvider.GetClassTypeByName(classname, NAME_MATCH.nmCaseSensitive, out Class));
                IEnumDebugFields Children;
                NativeMethods.ThrowOnFailure(
                    hr = Class.EnumFields(
                        (uint)(enum_FIELD_KIND.FIELD_KIND_ALL),
                        (uint)enum_FIELD_MODIFIERS.FIELD_MOD_ALL,
                        name, NAME_MATCH.nmCaseSensitive, out Children));
                if(hr == HResult.S_FALSE) return null;
                uint Count;
                NativeMethods.ThrowOnFailure(
                    Children.GetCount(out Count));
                if(Count == 0) return null;
                IDebugField[] info = new IDebugField[Count];
                NativeMethods.ThrowOnFailure(
                    Children.Next(Count, info, ref Count));
                if(Count == 0) return null;
                IDebugObject ret;
                EEDebugClassField This;
                NativeMethods.ThrowOnFailure(
                    new EEDebugMethodField(eeContainer.Field).GetThis(out This));
                IDebugObject ThisObj;
                NativeMethods.ThrowOnFailure(
                    context.Binder.Bind(null, This.Field, out ThisObj));
                NativeMethods.ThrowOnFailure(
                    context.Binder.Bind(ThisObj, info[0], out ret));
                return ret;
            }
            Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            return null;//never happens
        }
        /// <summary>Gets value of local variable or argument of curent method</summary>
        /// <param name="name">Name of variable or argument</param>
        /// <param name="context">Debugger context</param>
        /// <param name="dwTimenout">Timeout in ms</param>
        /// <returns><see cref="EEDebugObject"/> representing the value</returns>
        internal static EEDebugObject GetLocalObject(string name, DebuggerContext context, uint dwTimenout) {
            IDebugContainerField container;
            NativeMethods.ThrowOnFailure(context.SymbolProvider.GetContainerField(context.Address, out container));
            if(container == null)
                Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            EEDebugContainerField eeContainer = new EEDebugContainerField(container);
            if(eeContainer.IsMethod) {
                PropertyFactory factory = new PropertyFactory(context);
                PropertyBase ppProp;
                NativeMethods.ThrowOnFailure(
                    factory.CreateMethodProperty(new PropertyContext(context), eeContainer, out ppProp));
                var Children = ppProp.GetChildren(
                    new DebuggerRequestInfo(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ALL, 0, dwTimenout),
                    FilterGuids.LocalsPlusArgs, name);
                if(Children.Count == 0) return null;
                var Child = Children.GetItem(0);
                EEDebugObject ret;
                NativeMethods.ThrowOnFailure(
                    context.Bind(null, Child.BaseField, out ret));
                return ret;
            }
            Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            return null;//never happens
        }
       /// <summary>Creates <see cref="IDebugObject"/> representing string value</summary>
       /// <param name="OnFunction"><see cref="IDebugFunctionObject"/> to create object for</param>
       /// <param name="value">Strinng value to encapsulate</param>
       /// <returns><see cref="IDebugObject"/> representing the <paramref name="value"/> value</returns>
       internal static IDebugObject CreateStringObject(IDebugFunctionObject OnFunction, string value){
            IDebugObject ppObject;
            int hr;
#if DEBUG 
           try {
#endif
                NativeMethods.ThrowOnFailure(
                    hr = OnFunction.CreateStringObject(value, out ppObject));
                return ppObject;
#if DEBUG
           } catch(Exception ex) {
                Debug.Print(ex.Message);
                throw;
            }
#endif
        }
        /// <summary>Creates <see cref="IDebugObject"/> from primitive value</summary>
        /// <param name="OnFunction"><see cref="IDebugFunctionObject"/> to create object for</param>
        /// <param name="ot">Type of object to be created (use <see cref="enum_OBJECT_TYPE.OBJECT_TYPE_CLASS"/> for null values)</param>
        /// <param name="value">Value of object</param>
        /// <returns><see cref="IDebugObject"/> representing the <paramref name="value"/> value</returns>
        internal static IDebugObject CreatePrimitiveObject(IDebugFunctionObject OnFunction, enum_OBJECT_TYPE ot,object value) {
            IDebugObject ppObject;
#if DEBUG
            try {
#endif
                NativeMethods.ThrowOnFailure(
                    OnFunction.CreatePrimitiveObject((uint)ot, out ppObject));
                if(value != null)
                    using(System.IO.MemoryStream ms = new System.IO.MemoryStream()) {
                        System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
                        if(value is bool) bw.Write((bool)value);
                        else if(value is byte) bw.Write((byte)value);
                        else if(value is sbyte) bw.Write((sbyte)value);
                        else if(value is short) bw.Write((short)value);
                        else if(value is ushort) bw.Write((ushort)value);
                        else if(value is int) bw.Write((int)value);
                        else if(value is uint) bw.Write((uint)value);
                        else if(value is long) bw.Write((long)value);
                        else if(value is ulong) bw.Write((ulong)value);
                        else if(value is float) bw.Write((float)value);
                        else if(value is double) bw.Write((double)value);
                        else if(value is char) bw.Write((char)value);
                        else if(value is decimal) bw.Write((decimal)value);
                        else {
                            var f = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
                            f.Serialize(ms, value);
                        }
                        ms.Flush();
                        NativeMethods.ThrowOnFailure(
                            ppObject.SetValue(ms.GetBuffer(), (uint)ms.Length));
                    }
                return ppObject;
#if DEBUG
            } catch(Exception ex) {
                Debug.Print(ex.Message);
                throw;
            }
#endif
        }      
        /// <summary>Gets current PHP script contect as <see cref="IDebugObject"/></summary>
        /// <param name="context">Current debugger context</param>
        /// <param name="dwTimeout">Timeout in ms</param>
        /// <returns><see cref="IDebugObject"/> representing <see cref="PHP.Core.ScriptContext.CurrentContext"/> from process being debugged.</returns>
        internal static IDebugObject GetCurrentScriptContext(DebuggerContext context,uint dwTimeout) {
            int hr;
            IDebugFunctionObject get_CurrentContext = GetFunction(context, "PHP.Core.ScriptContext", "get_CurrentContext");
            IDebugObject CurrentContext;
            NativeMethods.ThrowOnFailure(
                hr = get_CurrentContext.Evaluate(new IDebugObject[0], (IntPtr)0, dwTimeout, out CurrentContext));
            return CurrentContext;
        }
        internal static IDebugFunctionObject GetFunction(DebuggerContext context, string parentType, string name) {
            return GetFunction(context, parentType, name, null);
        }
        /// <summary>Gets function by name and name of type</summary>
        /// <param name="context">Debugger context</param>
        /// <param name="parentType">Name of type (class) to get function of</param>
        /// <param name="name">Name of function</param>
        /// <returns><see cref="IDebugFunctionObject"/> representing function named <paramref name="name"/> of type <paramref name="parentType"/></returns>
        /// <remarks>Even getters and setters of properties can be got wne provided with right names (get_..., set_...).
        /// <para>Not tested for overloaded functions.</para></remarks>
        /// <param name="instance">Instance function will be later invoked on (null for static functions)</param>
        internal static IDebugFunctionObject GetFunction(DebuggerContext context,string parentType, string name,IDebugObject instance) {
            IDebugClassField ParentTypeField;
            int hr;
            NativeMethods.ThrowOnFailure(
                hr = context.SymbolProvider.GetClassTypeByName(parentType, NAME_MATCH.nmCaseSensitive, out ParentTypeField));
            if(hr != HResult.S_OK) return null;
            IEnumDebugFields ppEnum;
            NativeMethods.ThrowOnFailure(
                hr = ParentTypeField.EnumFields(
                    (uint)(enum_FIELD_KIND.FIELD_KIND_ALL),
                    (uint)enum_FIELD_MODIFIERS.FIELD_MOD_ALL,
                    name, NAME_MATCH.nmCaseSensitive, out ppEnum));
            uint count;
            NativeMethods.ThrowOnFailure(
                hr = ppEnum.GetCount(out count));
            if(count != 1) Marshal.ThrowExceptionForHR(HResult.E_FAIL);
            uint fcount = 0;
            IDebugField[] fields = new IDebugField[count];
            NativeMethods.ThrowOnFailure(
                hr = ppEnum.Next(count, fields, ref fcount));
            if(fcount != 1) Marshal.ThrowExceptionForHR(HResult.E_FAIL);
#if DEBUG
            FIELD_INFO[] fi = new FIELD_INFO[1];
            NativeMethods.ThrowOnFailure(
                hr = fields[0].GetInfo((uint)enum_FIELD_INFO_FIELDS.FIF_ALL, fi));
            Debug.Print(fi[0].bstrName);
#endif
            IDebugMethodField FunctionField = (IDebugMethodField)fields[0];
            IDebugObject FunctionObject;
            NativeMethods.ThrowOnFailure(
                hr = context.Binder.Bind(instance, FunctionField, out FunctionObject));
            return (IDebugFunctionObject)FunctionObject;
        }

    }

    
    /// <summary>Holds result of expression evauation</summary>
    internal class EvalObjectProperty:ObjectProperty {
        /// <summary>Contains value of the <see cref="OriginalExpression"/> property</summary>
        private readonly string originalExpression;
        /// <summary>Gets original expression, as string, being evaluated</summary>
        public string OriginalExpression { [DebuggerStepThrough]get { return originalExpression; } }
        /// <summary>CTor creates new instance of the <see cref="EvalObjectProperty"/> class</summary>
        /// <param name="context">Debugger context</param>
        /// <param name="baseObject">Result of evaluation</param>
        /// <param name="typeField">Identifies type</param>
        /// <param name="originalExpression">Original expression, as string, being evaluated</param>
        public EvalObjectProperty(PropertyContext context, EEDebugObject baseObject, EEDebugField typeField,string originalExpression)
            : base(context, typeField, baseObject, typeField) {
            this.originalExpression = originalExpression;
            this.internalObjectWrapper =new ObjectWrapper(context.DebuggerContext, baseObject.Object);
            this.internalObjectPropertyWrapper =internalObjectWrapper.GetProperty();
        }
        private readonly PropertyWrapper internalObjectPropertyWrapper;
        protected PropertyWrapper InternalObjectPropertyWrapper{[DebuggerStepThrough] get{return internalObjectPropertyWrapper ;}}
        protected ObjectWrapper InternalObjectWrapper { [DebuggerStepThrough] get { return internalObjectWrapper; } }
        private readonly ObjectWrapper internalObjectWrapper;
        /// <summary>Gets full name of this object</summary>
        /// <param name="req">ignored</param>
        /// <returns><see cref="OriginalExpression"/></returns>
        protected override string GetPropertyFullNameImpl(DebuggerRequestInfo req) {
            return OriginalExpression;
        }
        [DebuggerStepThrough]
        internal string _getpropertyfullnameimpl_(DebuggerRequestInfo req) {
            return GetPropertyFullNameImpl(req);
        }
        /// <summary>Gets name of this object</summary>
        /// <param name="req">ignored</param>
        /// <returns><see cref="OriginalExpression"/></returns>
        protected override string GetPropertyNameImpl(DebuggerRequestInfo req) {
            return OriginalExpression;
        }
        [DebuggerStepThrough]
        internal string _getpropertynameimpl_(DebuggerRequestInfo req) {
            return GetPropertyNameImpl(req);
        }
        /// <summary>Gets string representation of this object</summary>
        /// <returns><see cref="OriginalExpression"/></returns>
        public override string ToString() {
            return OriginalExpression;
        }
        protected override string GetPropertyValueImpl(DebuggerRequestInfo req) {
            switch(InternalObjectPropertyWrapper.TypeName) {
                case "System.String":
                    goto deserializeValue;
                case "System.Byte":
                case "System.SByte":
                case "System.Int16":
                case "System.UInt16":
                case "System.Int32":
                case "System.UInt32":
                case "System.Int64":
                case "System.UInt64":
                case "System.Single":
                case "System.Double":
                case "System.Decimal":
                case "System.Boolean":
                case "System.Char":
                    object value;    
                try {
                        value = internalObjectWrapper.GetManagedObject().GetValue();
                        return value.ToString();
                    } catch(NotImplementedException) {}
deserializeValue:
                    byte[] valuebytes = this.BaseObject.GetValue();
                    value = DeserializeValue(valuebytes, InternalObjectPropertyWrapper.TypeName);
                    return value.ToString();
                default: return base.GetPropertyValueImpl(req);                    
            }
        }
        private object DeserializeValue(byte[] bytes,string typeName){
            System.IO.MemoryStream ms = new System.IO.MemoryStream(bytes,false);
            System.IO.BinaryReader br = new System.IO.BinaryReader(ms);
            switch(typeName) {
                case "System.String":
                    char[] buffer = new char[bytes.Length];
                    int ReadCount =  br.Read(buffer, 0, bytes.Length);
                    return new string(buffer, 0, ReadCount);
                case "System.Byte": return br.ReadSByte();
                case "System.SByte": return br.ReadByte();
                case "System.Int16": return br.ReadInt16();
                case "System.UInt16": return br.ReadUInt16();
                case "System.Int32": return br.ReadInt32();
                case "System.UInt32": return br.ReadUInt32();
                case "System.Int64": return br.ReadInt64();
                case "System.UInt64": return br.ReadUInt64();
                case "System.Single": return br.ReadSingle();
                case "System.Double": return br.ReadDouble();
                case "System.Decimal": return br.ReadDecimal();
                case "System.Boolean": return br.ReadBoolean();
                case "System.Char": return br.ReadChar();
                default: throw new ArgumentException(string.Format(PHP.VisualStudio.PhalangerLanguageService.Resources.UnexpectedType0, typeName));
            }
        }
        [DebuggerStepThrough]
        internal string _getpropertyvalueimpl_(DebuggerRequestInfo req) {
            return GetPropertyValueImpl(req);
        }
        private bool ShouldEnumChildren() {
            switch(InternalObjectPropertyWrapper.TypeName) {
                case "System.String":
                case "System.Byte":
                case "System.SByte":
                case "System.Int16":
                case "System.UInt16":
                case "System.Int32":
                case "System.UInt32":
                case "System.Int64":
                case "System.UInt64":
                case "System.Single":
                case "System.Double":
                case "System.Decimal":
                case "System.Boolean":
                case "System.Char":
                    return false;
                default: return true;
            }
        }
        protected override int EnumChildren(DebuggerRequestInfo req, Guid guidFilter, string pszNameFilter, out EnumDebugPropertyInfo ppEnum) {
            if(!ShouldEnumChildren()) {
                ppEnum = null;
                return VSConstants.S_FALSE;
            }
            return base.EnumChildren(req, guidFilter, pszNameFilter, out ppEnum);
        }
        [DebuggerStepThrough]
        internal int _enumchildren_(DebuggerRequestInfo req, Guid guidFilter, string pszNameFilter, out EnumDebugPropertyInfo ppEnum) {
            return EnumChildren(req, guidFilter, pszNameFilter, out ppEnum);
        }
        public override int EnumChildren(uint dwFields, uint dwRadix, ref Guid guidFilter, ulong dwAttribFilter, string pszNameFilter, uint dwTimeout, out IEnumDebugPropertyInfo2 ppEnum) {
            if(!ShouldEnumChildren()) {
                ppEnum = null;
                return VSConstants.S_FALSE;
            }
            return base.EnumChildren(dwFields, dwRadix, ref guidFilter, dwAttribFilter, pszNameFilter, dwTimeout, out ppEnum);
        }
        [DebuggerStepThrough]
        internal int _enumchildren_(uint dwFields, uint dwRadix, ref Guid guidFilter, ulong dwAttribFilter, string pszNameFilter, uint dwTimeout, out IEnumDebugPropertyInfo2 ppEnum) {
            return EnumChildren(dwFields, dwRadix, ref guidFilter, dwAttribFilter, pszNameFilter, dwTimeout, out ppEnum);         
        }
        protected override string GetPropertyTypeImpl(DebuggerRequestInfo req) {
            switch(InternalObjectPropertyWrapper.TypeName) {
                case "System.String": return "string";
                case "System.Int32": return "int";
                case "System.Int64": return "int64";
                case "System.Double": return "double";
                case "System.Boolean": return "bool";
                default: return base.GetPropertyTypeImpl(req);
            }

        }
        [DebuggerStepThrough]
        internal string _getpropertytypeimpl_(DebuggerRequestInfo req) {
            return GetPropertyTypeImpl(req);
        }
        protected override Constants GetPropertyAttribImpl(DebuggerRequestInfo req) {
            var ret = base.GetPropertyAttribImpl(req);
            if(ShouldEnumChildren()) ret |= Constants.DBG_ATTRIB_OBJ_IS_EXPANDABLE;
            else ret &= ~Constants.DBG_ATTRIB_OBJ_IS_EXPANDABLE;
            return ret;
        }
        [DebuggerStepThrough]
        internal Constants _getpropertyattribimpl_(DebuggerRequestInfo req) {
            return GetPropertyAttribImpl(req);
        }
    }
    /// <summary>Holds result of expression evauation in case the result was <see cref="PHP.Core.Reflection.ClrObject"/></summary>
    internal class ClrObjectProperty:EvalObjectProperty {
        private EvalObjectProperty internalObject;
        public EvalObjectProperty  InternalObject { get { return internalObject; } }
        EvalObjectProperty RealObject;
        public ClrObjectProperty(PropertyContext context, EEDebugObject baseObject, EEDebugField typeField, string originalExpression) :
            base(context, baseObject, typeField, originalExpression) {
            IDebugFunctionObject get_RealObject = PHPDebugExpression.GetFunction(context.DebuggerContext, "PHP.Core.Reflection.ClrObject", "get_RealObject",baseObject.Object);
            IDebugObject realobject;
            NativeMethods.ThrowOnFailure(
                get_RealObject.Evaluate(new IDebugObject[0], IntPtr.Zero, 0, out realobject));
            EEDebugField typefield;
            EEDebugObject resultRE = new EEDebugObject(realobject);
            NativeMethods.ThrowOnFailure(
                resultRE.GetType(context.DebuggerContext, out typefield)); 
            this.RealObject = new EvalObjectProperty(context, new EEDebugObject(realobject), typeField, originalExpression);
        }
        protected override int EnumChildren(DebuggerRequestInfo req, Guid guidFilter, string pszNameFilter, out EnumDebugPropertyInfo ppEnum) {
            return internalObject._enumchildren_(req, guidFilter, pszNameFilter, out ppEnum);
        }
        public override int EnumChildren(uint dwFields, uint dwRadix, ref Guid guidFilter, ulong dwAttribFilter, string pszNameFilter, uint dwTimeout, out IEnumDebugPropertyInfo2 ppEnum) {
            return internalObject.EnumChildren(dwFields, dwRadix, ref guidFilter, dwAttribFilter, pszNameFilter, dwTimeout, out ppEnum);
        }
        protected override Constants GetPropertyAttribImpl(DebuggerRequestInfo req) {
            return internalObject._getpropertyattribimpl_(req);
        }
        protected override string GetPropertyFullNameImpl(DebuggerRequestInfo req) {
            return internalObject._getpropertyfullnameimpl_(req);
        }
        public override int GetPropertyInfo(DebuggerRequestInfo req, out DEBUG_PROPERTY_INFO retInfo) {
            return internalObject.GetPropertyInfo(req, out retInfo);
        }
        protected override string GetPropertyNameImpl(DebuggerRequestInfo req) {
            return internalObject._getpropertynameimpl_(req);
        }
        protected override string GetPropertyTypeImpl(DebuggerRequestInfo req) {
            return internalObject._getpropertytypeimpl_(req);
        }
        protected override string GetPropertyValueImpl(DebuggerRequestInfo req) {
            return internalObject._getpropertyvalueimpl_(req);
        }
    }

}